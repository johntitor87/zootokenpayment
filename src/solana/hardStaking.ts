import {
  Connection,
  Keypair,
  PublicKey,
  SystemProgram,
} from '@solana/web3.js';
import {
  getAssociatedTokenAddress,
  getOrCreateAssociatedTokenAccount,
  TOKEN_PROGRAM_ID,
} from '@solana/spl-token';
import * as fs from 'fs';
import * as path from 'path';
import { BN, Program, AnchorProvider, Wallet } from '@coral-xyz/anchor';
import { getTierFromAmount } from './tieredStaking';

/**
 * Hard Gating Staking System
 * 
 * Uses PDA vault for secure token locking
 * Only the program can move funds
 * Per-user stake accounts
 */

interface StakingConfig {
  programId: string;
  mintAddress: string;
  network?: 'devnet' | 'mainnet';
}

interface StakeInfo {
  user: string;
  amount: number;
  timestamp: number;
  unstakeTimestamp?: number;
  unlockTimestamp?: number;
  status: 'Active' | 'Unstaking' | 'Unstaked';
  tier: number;
  penaltyApplied: boolean;
}

interface ProposalInfo {
  authority: string;
  vault: string;
  mint: string;
  proposalId: number;
  votingStart: number;
  votingEnd: number;
  yesVotes: number;
  noVotes: number;
  status: 'Open' | 'Finalized' | 'Cancelled';
}

type ProgramIdl = any;

// Load wallet helper
function loadWallet(): Keypair {
  const walletPath = path.join(process.cwd(), 'wallet.json');
  if (!fs.existsSync(walletPath)) {
    throw new Error('Wallet not found. Please create a wallet first.');
  }
  const secretKey = JSON.parse(fs.readFileSync(walletPath, 'utf-8'));
  return Keypair.fromSecretKey(Uint8Array.from(secretKey));
}

function getConnection(network: 'devnet' | 'mainnet' = 'devnet'): Connection {
  const rpcUrl = network === 'devnet'
    ? 'https://api.devnet.solana.com'
    : 'https://api.mainnet.solana.com';
  return new Connection(rpcUrl, 'confirmed');
}

function loadIdl(): ProgramIdl {
  // Generated by `anchor build` (not committed by default)
  const idlPath = path.join(process.cwd(), 'staking-program', 'target', 'idl', 'zoostaking.json');
  if (!fs.existsSync(idlPath)) {
    throw new Error(
      `Anchor IDL not found at ${idlPath}. Run:\n` +
      `  cd staking-program\n` +
      `  anchor build\n` +
      `Then re-run this command.`
    );
  }
  return JSON.parse(fs.readFileSync(idlPath, 'utf-8'));
}

function makeProvider(connection: Connection, wallet: Keypair): AnchorProvider {
  return new AnchorProvider(
    connection,
    {
      publicKey: wallet.publicKey,
      signTransaction: async (tx) => {
        tx.sign(wallet);
        return tx;
      },
      signAllTransactions: async (txs) => {
        txs.forEach((tx) => tx.sign(wallet));
        return txs;
      },
    } as Wallet,
    { commitment: 'confirmed' }
  );
}

function makeProgram(connection: Connection, wallet: Keypair, programId: PublicKey) {
  const idl = loadIdl();
  const provider = makeProvider(connection, wallet);
  return new Program(idl, programId, provider);
}

/**
 * Get PDA addresses
 */
export function getVaultPDA(mint: PublicKey, programId: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from('vault'), mint.toBuffer()],
    programId
  );
}

export function getStakeAccountPDA(
  vault: PublicKey,
  user: PublicKey,
  programId: PublicKey
): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from('stake'), vault.toBuffer(), user.toBuffer()],
    programId
  );
}

export function getProposalPDA(
  vault: PublicKey,
  proposalId: number,
  programId: PublicKey
): [PublicKey, number] {
  const buf = Buffer.alloc(8);
  buf.writeBigUInt64LE(BigInt(proposalId));
  return PublicKey.findProgramAddressSync(
    [Buffer.from('proposal'), vault.toBuffer(), buf],
    programId
  );
}

export function getVoteRecordPDA(
  proposal: PublicKey,
  voter: PublicKey,
  programId: PublicKey
): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from('vote'), proposal.toBuffer(), voter.toBuffer()],
    programId
  );
}

/**
 * Initialize vault (one-time setup)
 */
export async function initializeVault(config: StakingConfig): Promise<string> {
  const connection = getConnection(config.network);
  const wallet = loadWallet();
  const mint = new PublicKey(config.mintAddress);
  const programId = new PublicKey(config.programId);

  const program = makeProgram(connection, wallet, programId);

  const [vaultPDA] = getVaultPDA(mint, programId);

  // Get or create vault token account
  const vaultTokenAccount = await getOrCreateAssociatedTokenAccount(
    connection,
    wallet,
    mint,
    vaultPDA,
    true // allowOwnerOffCurve
  );

  try {
    const tx = await program.methods
      .initializeVault()
      .accounts({
        vault: vaultPDA,
        authority: wallet.publicKey,
        mint: mint,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log(`\n‚úÖ Vault initialized!`);
    console.log(`   Vault PDA: ${vaultPDA.toBase58()}`);
    console.log(`   Vault Token Account: ${vaultTokenAccount.address.toBase58()}`);
    console.log(`   Signature: ${tx}`);

    return tx;
  } catch (error: any) {
    if (error.message?.includes('already in use')) {
      console.log(`\n‚úÖ Vault already initialized`);
      return 'already-initialized';
    }
    throw error;
  }
}

/**
 * Stake tokens - Lock tokens in vault
 */
export async function stakeTokens(
  amount: number,
  config: StakingConfig,
  userAddress?: string
): Promise<string> {
  const connection = getConnection(config.network);
  const wallet = loadWallet();
  const user = userAddress ? new PublicKey(userAddress) : wallet.publicKey;
  const mint = new PublicKey(config.mintAddress);
  const programId = new PublicKey(config.programId);

  const program = makeProgram(connection, wallet, programId);

  const [vaultPDA] = getVaultPDA(mint, programId);
  const [stakeAccountPDA] = getStakeAccountPDA(vaultPDA, user, programId);

  // Get token accounts
  const userTokenAccount = await getAssociatedTokenAddress(mint, user);
  const vaultTokenAccount = await getAssociatedTokenAddress(mint, vaultPDA, true);

  const amountBN = new BN(amount * Math.pow(10, 9)); // Assuming 9 decimals

  console.log(`\nüîí Staking ${amount} tokens...`);
  console.log(`   User: ${user.toBase58()}`);
  console.log(`   Vault: ${vaultPDA.toBase58()}`);

  const tx = await program.methods
    .stake(amountBN)
    .accounts({
      vault: vaultPDA,
      stakeAccount: stakeAccountPDA,
      user: user,
      userTokenAccount: userTokenAccount,
      vaultTokenAccount: vaultTokenAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: SystemProgram.programId,
    })
    .rpc();

  console.log(`‚úÖ Staked ${amount} tokens`);
  console.log(`   Signature: ${tx}`);

  return tx;
}

/**
 * Request unstake - Start 2-day lock period (access revoked immediately)
 */
export async function requestUnstake(
  config: StakingConfig,
  userAddress?: string
): Promise<string> {
  const connection = getConnection(config.network);
  const wallet = loadWallet();
  const user = userAddress ? new PublicKey(userAddress) : wallet.publicKey;
  const mint = new PublicKey(config.mintAddress);
  const programId = new PublicKey(config.programId);

  const program = makeProgram(connection, wallet, programId);

  const [vaultPDA] = getVaultPDA(mint, programId);
  const [stakeAccountPDA] = getStakeAccountPDA(vaultPDA, user, programId);

  console.log(`\nüîì Requesting unstake (2-day lock period starts)...`);
  console.log(`   User: ${user.toBase58()}`);
  console.log(`   ‚ö†Ô∏è  Access will be revoked immediately`);

  const tx = await program.methods
    .requestUnstake()
    .accounts({
      vault: vaultPDA,
      stakeAccount: stakeAccountPDA,
      user: user,
      systemProgram: SystemProgram.programId,
    })
    .rpc();

  console.log(`‚úÖ Unstake requested`);
  console.log(`   Signature: ${tx}`);
  console.log(`   ‚è≥ Tokens will unlock in 2 days`);
  console.log(`   ‚ùå Access revoked immediately`);

  return tx;
}

/**
 * Complete unstake - Withdraw tokens after 2-day lock period
 */
export async function completeUnstake(
  config: StakingConfig,
  userAddress?: string
): Promise<string> {
  const connection = getConnection(config.network);
  const wallet = loadWallet();
  const user = userAddress ? new PublicKey(userAddress) : wallet.publicKey;
  const mint = new PublicKey(config.mintAddress);
  const programId = new PublicKey(config.programId);

  const program = makeProgram(connection, wallet, programId);

  const [vaultPDA] = getVaultPDA(mint, programId);
  const [stakeAccountPDA] = getStakeAccountPDA(vaultPDA, user, programId);

  // Get token accounts
  const userTokenAccount = await getAssociatedTokenAddress(mint, user);
  const vaultTokenAccount = await getAssociatedTokenAddress(mint, vaultPDA, true);

  console.log(`\nüîì Completing unstake (after 2-day lock)...`);
  console.log(`   User: ${user.toBase58()}`);

  const tx = await program.methods
    .completeUnstake()
    .accounts({
      vault: vaultPDA,
      stakeAccount: stakeAccountPDA,
      user: user,
      userTokenAccount: userTokenAccount,
      vaultTokenAccount: vaultTokenAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: SystemProgram.programId,
    })
    .rpc();

  console.log(`‚úÖ Unstake completed`);
  console.log(`   Signature: ${tx}`);
  console.log(`   ‚ö†Ô∏è  Penalty may apply if unstaking within 3 days`);

  return tx;
}

/**
 * Get stake info (read-only)
 */
export async function getStakeInfo(
  userAddress: string,
  config: StakingConfig
): Promise<StakeInfo | null> {
  const connection = getConnection(config.network);
  const wallet = loadWallet(); // used as provider wallet (read-only is fine)
  const mint = new PublicKey(config.mintAddress);
  const programId = new PublicKey(config.programId);
  const user = new PublicKey(userAddress);

  const [vaultPDA] = getVaultPDA(mint, programId);
  const [stakeAccountPDA] = getStakeAccountPDA(vaultPDA, user, programId);

  try {
    const program = makeProgram(connection, wallet, programId);
    const stakeAccount: any = await (program.account as any).stakeAccount.fetchNullable(stakeAccountPDA);
    if (!stakeAccount) return null;

    const amountRaw: number =
      typeof stakeAccount.amount?.toNumber === 'function' ? stakeAccount.amount.toNumber() : Number(stakeAccount.amount ?? 0);

    const timestamp: number =
      typeof stakeAccount.timestamp?.toNumber === 'function' ? stakeAccount.timestamp.toNumber() : Number(stakeAccount.timestamp ?? 0);

    const unstakeTimestamp: number | undefined = (() => {
      const v = stakeAccount.unstakeTimestamp ?? stakeAccount.unstake_timestamp ?? null;
      if (v === null || v === undefined) return undefined;
      if (typeof v?.toNumber === 'function') return v.toNumber();
      return Number(v);
    })();

    const penaltyApplied: boolean = Boolean(
      stakeAccount.penaltyApplied ?? stakeAccount.penalty_applied ?? false
    );

    const status: StakeInfo['status'] = (() => {
      const s = stakeAccount.status;
      if (!s) return 'Unstaked';
      // Anchor enums decode to objects like { active: {} } / { unstaking: {} } / { unstaked: {} }
      if (s.active !== undefined) return 'Active';
      if (s.unstaking !== undefined) return 'Unstaking';
      if (s.unstaked !== undefined) return 'Unstaked';
      // Fallback if it somehow comes back as a string
      const asStr = String(s);
      if (asStr.toLowerCase().includes('unstaking')) return 'Unstaking';
      if (asStr.toLowerCase().includes('active')) return 'Active';
      return 'Unstaked';
    })();

    const amountTokens = amountRaw / Math.pow(10, 9);
    const tier = getTierFromAmount(amountTokens);

    const unlockTimestamp =
      status === 'Unstaking' && unstakeTimestamp !== undefined
        ? unstakeTimestamp + (2 * 24 * 60 * 60)
        : undefined;

    return {
      user: userAddress,
      amount: amountRaw,
      timestamp,
      unstakeTimestamp,
      unlockTimestamp,
      status,
      tier,
      penaltyApplied,
    };
  } catch (error) {
    return null;
  }
}

/**
 * Check if user has staked tokens (for WooCommerce gating)
 */
export async function checkStakeGate(
  userAddress: string,
  requiredAmount: number,
  config: StakingConfig
): Promise<{ hasAccess: boolean; stakedAmount: number }> {
  const stakeInfo = await getStakeInfo(userAddress, config);
  
  if (!stakeInfo || stakeInfo.status !== 'Active') {
    return { hasAccess: false, stakedAmount: 0 };
  }

  const hasAccess = stakeInfo.amount >= requiredAmount * Math.pow(10, 9);
  
  return {
    hasAccess,
    stakedAmount: stakeInfo.amount / Math.pow(10, 9),
  };
}

/**
 * Governance: Create a proposal (admin)
 */
export async function createProposal(
  proposalId: number,
  votingStart: number,
  votingEnd: number,
  config: StakingConfig,
  authorityAddress?: string
): Promise<string> {
  const connection = getConnection(config.network);
  const wallet = loadWallet();
  const authority = authorityAddress ? new PublicKey(authorityAddress) : wallet.publicKey;
  const mint = new PublicKey(config.mintAddress);
  const programId = new PublicKey(config.programId);

  const program = makeProgram(connection, wallet, programId);
  const [vaultPDA] = getVaultPDA(mint, programId);
  const [proposalPDA] = getProposalPDA(vaultPDA, proposalId, programId);

  const tx = await program.methods
    .createProposal(new BN(proposalId), new BN(votingStart), new BN(votingEnd))
    .accounts({
      vault: vaultPDA,
      proposal: proposalPDA,
      authority,
      systemProgram: SystemProgram.programId,
    })
    .rpc();

  return tx;
}

/**
 * Governance: Cast vote (weight = current staked amount)
 */
export async function castVote(
  proposalId: number,
  choiceYes: boolean,
  config: StakingConfig,
  voterAddress?: string
): Promise<string> {
  const connection = getConnection(config.network);
  const wallet = loadWallet();
  const voter = voterAddress ? new PublicKey(voterAddress) : wallet.publicKey;
  const mint = new PublicKey(config.mintAddress);
  const programId = new PublicKey(config.programId);

  const program = makeProgram(connection, wallet, programId);
  const [vaultPDA] = getVaultPDA(mint, programId);
  const [proposalPDA] = getProposalPDA(vaultPDA, proposalId, programId);
  const [voteRecordPDA] = getVoteRecordPDA(proposalPDA, voter, programId);
  const [stakeAccountPDA] = getStakeAccountPDA(vaultPDA, voter, programId);

  const tx = await program.methods
    .castVote(choiceYes)
    .accounts({
      vault: vaultPDA,
      proposal: proposalPDA,
      voteRecord: voteRecordPDA,
      stakeAccount: stakeAccountPDA,
      voter,
      systemProgram: SystemProgram.programId,
    })
    .rpc();

  return tx;
}

/**
 * Governance: Finalize proposal
 */
export async function finalizeProposal(
  proposalId: number,
  config: StakingConfig,
  closerAddress?: string
): Promise<string> {
  const connection = getConnection(config.network);
  const wallet = loadWallet();
  const closer = closerAddress ? new PublicKey(closerAddress) : wallet.publicKey;
  const mint = new PublicKey(config.mintAddress);
  const programId = new PublicKey(config.programId);

  const program = makeProgram(connection, wallet, programId);
  const [vaultPDA] = getVaultPDA(mint, programId);
  const [proposalPDA] = getProposalPDA(vaultPDA, proposalId, programId);

  const tx = await program.methods
    .finalizeProposal()
    .accounts({
      vault: vaultPDA,
      proposal: proposalPDA,
      closer,
    })
    .rpc();

  return tx;
}

/**
 * Governance: Get proposal data
 */
export async function getProposal(
  proposalId: number,
  config: StakingConfig
): Promise<ProposalInfo | null> {
  const connection = getConnection(config.network);
  const wallet = loadWallet();
  const mint = new PublicKey(config.mintAddress);
  const programId = new PublicKey(config.programId);
  const program = makeProgram(connection, wallet, programId);
  const [vaultPDA] = getVaultPDA(mint, programId);
  const [proposalPDA] = getProposalPDA(vaultPDA, proposalId, programId);

  const proposal: any = await (program.account as any).proposal.fetchNullable(proposalPDA);
  if (!proposal) return null;

  const status: ProposalInfo['status'] = (() => {
    const s = proposal.status;
    if (s?.open !== undefined) return 'Open';
    if (s?.finalized !== undefined) return 'Finalized';
    if (s?.cancelled !== undefined) return 'Cancelled';
    const asStr = String(s);
    if (asStr.toLowerCase().includes('final')) return 'Finalized';
    if (asStr.toLowerCase().includes('cancel')) return 'Cancelled';
    return 'Open';
  })();

  const yesVotes = typeof proposal.yesVotes?.toNumber === 'function' ? proposal.yesVotes.toNumber() : Number(proposal.yesVotes ?? 0);
  const noVotes = typeof proposal.noVotes?.toNumber === 'function' ? proposal.noVotes.toNumber() : Number(proposal.noVotes ?? 0);
  const votingStart = typeof proposal.votingStart?.toNumber === 'function' ? proposal.votingStart.toNumber() : Number(proposal.votingStart ?? 0);
  const votingEnd = typeof proposal.votingEnd?.toNumber === 'function' ? proposal.votingEnd.toNumber() : Number(proposal.votingEnd ?? 0);
  const proposalIdDecoded = typeof proposal.proposalId?.toNumber === 'function' ? proposal.proposalId.toNumber() : Number(proposal.proposalId ?? proposalId);

  return {
    authority: String(proposal.authority),
    vault: String(proposal.vault),
    mint: String(proposal.mint),
    proposalId: proposalIdDecoded,
    votingStart,
    votingEnd,
    yesVotes,
    noVotes,
    status,
  };
}





